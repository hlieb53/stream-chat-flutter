import 'dart:convert';

import 'package:shared_preferences/shared_preferences.dart';
import 'package:stream_chat/src/api/responses.dart';
import 'package:stream_chat/src/models/channel_model.dart';
import 'package:stream_chat/src/models/channel_state.dart';
import 'package:stream_chat/src/models/message.dart';
import 'package:meta/meta.dart';

import 'client.dart';
import 'models/own_user.dart';

/// Utility class to handle and show notifications
class NotificationService {
  static Future<void> _handleNotification(
    Message message,
    ChannelModel channelModel,
    Client client,
  ) async {
    if (message != null && client.persistenceEnabled) {
      if (client?.state?.channels == null) {
        final chatPersistenceClient = client.chatPersistenceClient;
        await chatPersistenceClient.updateChannelState(
          ChannelState(
            channel: channelModel,
            messages: [message],
          ),
        );
      } else {
        final channel = client.state.channels[channelModel.cid];
        channel.state.updateChannelState(
          ChannelState(
            channel: channelModel,
            messages: [message],
          ),
        );
      }
    }
  }

  static SharedPreferences _sharedPreferences;

  static Future<SharedPreferences> _getSharedPreferences() async {
    _sharedPreferences ??= await SharedPreferences.getInstance();
    return _sharedPreferences;
  }

  /// Gets the message using the client without storing it in the offline storage
  /// It returns an object containing the information about the message and the channel
  static Future<GetMessageResponse> _getMessage(String messageId) async {
    final sharedPreferences = await _getSharedPreferences();
    final apiKey = sharedPreferences.getString(KEY_API_KEY);

    final client = Client(apiKey);
    final userId = sharedPreferences.getString(KEY_USER_ID);
    final token = sharedPreferences.getString(KEY_TOKEN);

    client.state.user = OwnUser(id: userId);
    client.token = token;

    final res = await client.getMessage(messageId);
    return res;
  }

  /// Gets the message using the client and calls a [storeMessageHandler] callback
  /// with the message if the user wants to save the message in db
  ///
  /// It returns an object containing the information about the message and the channel
  static Future<GetMessageResponse> getAndStoreMessage({
    @required String messageId,
    @required Future<void> Function(GetMessageResponse) storeMessageHandler,
  }) async {
    final getMessageResponse = await _getMessage(messageId);
    await storeMessageHandler(getMessageResponse);
    return getMessageResponse;
  }

  /// Handles the ios message queue generated by the Notification Service Extension
  static Future<void> handleIosMessageQueue(Client client) async {
    final sharedPreferences = await SharedPreferences.getInstance();
    await sharedPreferences.reload();
    final messageQueue = sharedPreferences.getStringList('messageQueue');
    if (messageQueue != null) {
      messageQueue.forEach((m) {
        final jsonMessage = jsonDecode(m);

        final message = Message.fromJson(jsonMessage);
        final channelModel = ChannelModel.fromJson(jsonMessage['channel']);

        _handleNotification(
          message,
          channelModel,
          client,
        );
      });
      await sharedPreferences.remove('messageQueue');
    }
  }
}
